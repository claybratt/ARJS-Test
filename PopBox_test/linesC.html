<!doctype HTML>
<html>
  <head>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/dev/aframe/build/aframe-ar.js"></script>
  </head>

  <body style="margin: 0; overflow: hidden;">

    <script>
      // how long (ms) we keep objects after losing marker tracking
      const VISIBILITY_TIMEOUT = 3000;

      // per-marker state: visible + lastSeen timestamp
      const markerState = {
        m1: { visible: false, lastSeen: 0 },
        m2: { visible: false, lastSeen: 0 },
        m3: { visible: false, lastSeen: 0 },
        m4: { visible: false, lastSeen: 0 }
      };

      AFRAME.registerComponent('registerevents', {
        init: function () {
          const marker = this.el;
          const id = marker.id;

          marker.addEventListener('markerFound', () => {
            const now = performance.now();
            if (markerState[id]) {
              markerState[id].visible = true;
              markerState[id].lastSeen = now;
            }
          });

          marker.addEventListener('markerLost', () => {
            const now = performance.now();
            if (markerState[id]) {
              markerState[id].visible = false;
              markerState[id].lastSeen = now;
            }
          });
        }
      });

      AFRAME.registerComponent('run', {
        init: function () {
          // marker entities
          this.m1 = document.querySelector("#m1");
          this.m2 = document.querySelector("#m2");
          this.m3 = document.querySelector("#m3");
          this.m4 = document.querySelector("#m4");

          // follower entities for persistent spheres (world space)
          this.f1 = document.querySelector("#follower-m1").object3D;
          this.f2 = document.querySelector("#follower-m2").object3D;
          this.f3 = document.querySelector("#follower-m3").object3D;
          this.f4 = document.querySelector("#follower-m4").object3D;

          // reusable vectors for last known positions (world space)
          this.p1 = new THREE.Vector3();
          this.p2 = new THREE.Vector3();
          this.p3 = new THREE.Vector3();
          this.p4 = new THREE.Vector3();

          // cylinder geometry/material
          const cylGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 12);
          cylGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
          cylGeometry.applyMatrix4(
            new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90))
          );
          const cylMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });

          // cylinders between markers (1-2, 2-3, 3-4)
          this.cylinder12 = new THREE.Mesh(cylGeometry, cylMaterial);
          this.cylinder23 = new THREE.Mesh(cylGeometry, cylMaterial);
          this.cylinder34 = new THREE.Mesh(cylGeometry, cylMaterial);

          // groups are direct children of the scene (world space)
          this.cylinderGroup12 = document.querySelector('#cylinderGroup12').object3D;
          this.cylinderGroup23 = document.querySelector('#cylinderGroup23').object3D;
          this.cylinderGroup34 = document.querySelector('#cylinderGroup34').object3D;

          this.cylinderGroup12.add(this.cylinder12);
          this.cylinderGroup23.add(this.cylinder23);
          this.cylinderGroup34.add(this.cylinder34);

          // initially hide cylinders
          this.cylinder12.visible = false;
          this.cylinder23.visible = false;
          this.cylinder34.visible = false;

          // ---------- RECTANGLE (TRUE QUAD) SETUP ----------

          this.rectGroup = document.querySelector('#rectGroup').object3D;

          // 4 vertices, xyz each
          const rectPositions = new Float32Array(4 * 3);
          const rectGeometry = new THREE.BufferGeometry();
          rectGeometry.setAttribute(
            'position',
            new THREE.BufferAttribute(rectPositions, 3)
          );
          rectGeometry.setIndex([
            0, 1, 2,   // first triangle
            0, 2, 3    // second triangle
          ]);

          const rectMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.4
          });

          const rectMesh = new THREE.Mesh(rectGeometry, rectMaterial);
          rectMesh.visible = false;
          // make sure it doesn't disappear due to bad bounding box / culling
          rectMesh.frustumCulled = false;

          this.rectPositions = rectPositions;
          this.rectGeometry = rectGeometry;
          this.rectMesh = rectMesh;

          this.rectGroup.add(rectMesh);
        },

        _markerWithinTimeout(id, now) {
          const state = markerState[id];
          if (!state) return false;

          // If it's currently visible, always treat as "within timeout"
          if (state.visible) return true;

          // If it's not visible, check how long ago we last saw it
          return (now - state.lastSeen) < VISIBILITY_TIMEOUT;
        },

        tick: function (time, deltaTime) {
          const now = performance.now();

          // --- update last known positions when markers are visible ---

          if (markerState.m1.visible) {
            this.m1.object3D.getWorldPosition(this.p1);
            this.f1.position.copy(this.p1);
            markerState.m1.lastSeen = now;
          }
          if (markerState.m2.visible) {
            this.m2.object3D.getWorldPosition(this.p2);
            this.f2.position.copy(this.p2);
            markerState.m2.lastSeen = now;
          }
          if (markerState.m3.visible) {
            this.m3.object3D.getWorldPosition(this.p3);
            this.f3.position.copy(this.p3);
            markerState.m3.lastSeen = now;
          }
          if (markerState.m4.visible) {
            this.m4.object3D.getWorldPosition(this.p4);
            this.f4.position.copy(this.p4);
            markerState.m4.lastSeen = now;
          }

          // --- show/hide follower spheres based on timeout ---

          this.f1.visible = this._markerWithinTimeout('m1', now);
          this.f2.visible = this._markerWithinTimeout('m2', now);
          this.f3.visible = this._markerWithinTimeout('m3', now);
          this.f4.visible = this._markerWithinTimeout('m4', now);

          // --- cylinders use last known positions and are in world space ---

          // m1-m2
          if (this._markerWithinTimeout('m1', now) && this._markerWithinTimeout('m2', now)) {
            const distance = this.p1.distanceTo(this.p2);
            this.cylinderGroup12.position.copy(this.p1);
            this.cylinderGroup12.lookAt(this.p2);
            this.cylinder12.scale.set(1, 1, distance);
            this.cylinder12.visible = true;
          } else {
            this.cylinder12.visible = false;
          }

          // m2-m3
          if (this._markerWithinTimeout('m2', now) && this._markerWithinTimeout('m3', now)) {
            const distance = this.p2.distanceTo(this.p3);
            this.cylinderGroup23.position.copy(this.p2);
            this.cylinderGroup23.lookAt(this.p3);
            this.cylinder23.scale.set(1, 1, distance);
            this.cylinder23.visible = true;
          } else {
            this.cylinder23.visible = false;
          }

          // m3-m4
          if (this._markerWithinTimeout('m3', now) && this._markerWithinTimeout('m4', now)) {
            const distance = this.p3.distanceTo(this.p4);
            this.cylinderGroup34.position.copy(this.p3);
            this.cylinderGroup34.lookAt(this.p4);
            this.cylinder34.scale.set(1, 1, distance);
            this.cylinder34.visible = true;
          } else {
            this.cylinder34.visible = false;
          }

          // ---------- RECTANGLE UPDATE (m1, m2, m3, m4) ----------

          const quadOk =
            this._markerWithinTimeout('m1', now) &&
            this._markerWithinTimeout('m2', now) &&
            this._markerWithinTimeout('m3', now) &&
            this._markerWithinTimeout('m4', now);

          if (quadOk) {
            const pos = this.rectPositions;

            // Set each vertex to exactly each marker position (world space).
            // Order them so they walk around the shape:
            // v0 = m1, v1 = m2, v2 = m3, v3 = m4
            pos[0]  = this.p1.x; pos[1]  = this.p1.y; pos[2]  = this.p1.z;
            pos[3]  = this.p2.x; pos[4]  = this.p2.y; pos[5]  = this.p2.z;
            pos[6]  = this.p3.x; pos[7]  = this.p3.y; pos[8]  = this.p3.z;
            pos[9]  = this.p4.x; pos[10] = this.p4.y; pos[11] = this.p4.z;

            this.rectGeometry.attributes.position.needsUpdate = true;
            // update normals & bounds in case you care about lighting / culling
            this.rectGeometry.computeVertexNormals();
            this.rectGeometry.computeBoundingSphere();

            this.rectMesh.visible = true;
          } else {
            this.rectMesh.visible = false;
          }
        }
      });
    </script>

    <a-scene
      embedded
      vr-mode-ui="enabled: false;"
      arjs="debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 4x4_BCH_13_5_5;"
    >
      <!-- simple lights -->
      <a-entity light="type: directional; intensity: 0.8;" position="0 1 0"></a-entity>
      <a-entity light="type: ambient; intensity: 0.4;"></a-entity>

      <!-- Markers: 1â€“4 only -->
      <a-marker type="barcode" value="1" id="m1" registerevents></a-marker>
      <a-marker type="barcode" value="2" id="m2" registerevents></a-marker>
      <a-marker type="barcode" value="3" id="m3" registerevents></a-marker>
      <a-marker type="barcode" value="4" id="m4" registerevents></a-marker>

      <!-- Followers: persistent spheres in world space -->
      <a-entity id="follower-m1">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m2">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m3">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m4">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <!-- Cylinder groups: direct children of scene (world space) -->
      <a-entity id="cylinderGroup12"></a-entity>
      <a-entity id="cylinderGroup23"></a-entity>
      <a-entity id="cylinderGroup34"></a-entity>

      <!-- Rect group: quad mesh is attached here as a world-space object -->
      <a-entity id="rectGroup"></a-entity>

      <a-entity camera></a-entity>
      <a-entity run></a-entity>
    </a-scene>
  </body>
</html>
