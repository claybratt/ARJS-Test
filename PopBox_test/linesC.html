<!doctype HTML>
<html>
  <head>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/dev/aframe/build/aframe-ar.js"></script>
  </head>

  <body style="margin: 0; overflow: hidden;">

    <script>
      // how long (ms) we keep objects after losing marker tracking
      const VISIBILITY_TIMEOUT = 3000;

      // per-marker state: visible + lastSeen timestamp
      const markerState = {
        m1: { visible: false, lastSeen: 0 },
        m2: { visible: false, lastSeen: 0 },
        m3: { visible: false, lastSeen: 0 },
        m4: { visible: false, lastSeen: 0 }
      };

      AFRAME.registerComponent('registerevents', {
        init: function () {
          const marker = this.el;
          const id = marker.id;

          marker.addEventListener('markerFound', () => {
            const now = performance.now();
            if (markerState[id]) {
              markerState[id].visible = true;
              markerState[id].lastSeen = now;
            }
          });

          marker.addEventListener('markerLost', () => {
            const now = performance.now();
            if (markerState[id]) {
              markerState[id].visible = false;
              markerState[id].lastSeen = now;
            }
          });
        }
      });

      AFRAME.registerComponent('run', {
        init: function () {
          // marker entities
          this.m1 = document.querySelector("#m1");
          this.m2 = document.querySelector("#m2");
          this.m3 = document.querySelector("#m3");
          this.m4 = document.querySelector("#m4");

          // follower entities for persistent spheres (world space)
          this.f1 = document.querySelector("#follower-m1").object3D;
          this.f2 = document.querySelector("#follower-m2").object3D;
          this.f3 = document.querySelector("#follower-m3").object3D;
          this.f4 = document.querySelector("#follower-m4").object3D;

          // reusable vectors for last known positions (world space)
          this.p1 = new THREE.Vector3();
          this.p2 = new THREE.Vector3();
          this.p3 = new THREE.Vector3();
          this.p4 = new THREE.Vector3();

          // cylinder geometry/material
          const cylGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 12);
          cylGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
          cylGeometry.applyMatrix4(
            new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90))
          );
          const cylMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });

          // cylinders between markers (1-2, 2-3, 3-4)
          this.cylinder12 = new THREE.Mesh(cylGeometry, cylMaterial);
          this.cylinder23 = new THREE.Mesh(cylGeometry, cylMaterial);
          this.cylinder34 = new THREE.Mesh(cylGeometry, cylMaterial);

          // groups are direct children of the scene (world space)
          this.cylinderGroup12 = document.querySelector('#cylinderGroup12').object3D;
          this.cylinderGroup23 = document.querySelector('#cylinderGroup23').object3D;
          this.cylinderGroup34 = document.querySelector('#cylinderGroup34').object3D;

          this.cylinderGroup12.add(this.cylinder12);
          this.cylinderGroup23.add(this.cylinder23);
          this.cylinderGroup34.add(this.cylinder34);

          // initially hide cylinders
          this.cylinder12.visible = false;
          this.cylinder23.visible = false;
          this.cylinder34.visible = false;

          // ---------- RECTANGLE PLANE SETUP ----------

          this.rectPlane = document.querySelector('#rectPlane').object3D;
          this.rectPlane.visible = false;

          // temp objects for orientation math
          this.center = new THREE.Vector3();
          this.right = new THREE.Vector3();
          this.up = new THREE.Vector3();
          this.normal = new THREE.Vector3();
          this.basisMatrix = new THREE.Matrix4();
          this.tempQuat = new THREE.Quaternion();
        },

        _markerWithinTimeout(id, now) {
          const state = markerState[id];
          if (!state) return false;

          // If it's currently visible, always treat as "within timeout"
          if (state.visible) return true;

          // If it's not visible, check how long ago we last saw it
          return (now - state.lastSeen) < VISIBILITY_TIMEOUT;
        },

        tick: function (time, deltaTime) {
          const now = performance.now();

          // --- update last known positions when markers are visible ---

          if (markerState.m1.visible) {
            this.m1.object3D.getWorldPosition(this.p1);
            this.f1.position.copy(this.p1);
            markerState.m1.lastSeen = now;
          }
          if (markerState.m2.visible) {
            this.m2.object3D.getWorldPosition(this.p2);
            this.f2.position.copy(this.p2);
            markerState.m2.lastSeen = now;
          }
          if (markerState.m3.visible) {
            this.m3.object3D.getWorldPosition(this.p3);
            this.f3.position.copy(this.p3);
            markerState.m3.lastSeen = now;
          }
          if (markerState.m4.visible) {
            this.m4.object3D.getWorldPosition(this.p4);
            this.f4.position.copy(this.p4);
            markerState.m4.lastSeen = now;
          }

          // --- show/hide follower spheres based on timeout ---

          this.f1.visible = this._markerWithinTimeout('m1', now);
          this.f2.visible = this._markerWithinTimeout('m2', now);
          this.f3.visible = this._markerWithinTimeout('m3', now);
          this.f4.visible = this._markerWithinTimeout('m4', now);

          // --- cylinders use last known positions and are in world space ---

          // m1-m2
          if (this._markerWithinTimeout('m1', now) && this._markerWithinTimeout('m2', now)) {
            const distance = this.p1.distanceTo(this.p2);
            this.cylinderGroup12.position.copy(this.p1);
            this.cylinderGroup12.lookAt(this.p2);
            this.cylinder12.scale.set(1, 1, distance);
            this.cylinder12.visible = true;
          } else {
            this.cylinder12.visible = false;
          }

          // m2-m3
          if (this._markerWithinTimeout('m2', now) && this._markerWithinTimeout('m3', now)) {
            const distance = this.p2.distanceTo(this.p3);
            this.cylinderGroup23.position.copy(this.p2);
            this.cylinderGroup23.lookAt(this.p3);
            this.cylinder23.scale.set(1, 1, distance);
            this.cylinder23.visible = true;
          } else {
            this.cylinder23.visible = false;
          }

          // m3-m4
          if (this._markerWithinTimeout('m3', now) && this._markerWithinTimeout('m4', now)) {
            const distance = this.p3.distanceTo(this.p4);
            this.cylinderGroup34.position.copy(this.p3);
            this.cylinderGroup34.lookAt(this.p4);
            this.cylinder34.scale.set(1, 1, distance);
            this.cylinder34.visible = true;
          } else {
            this.cylinder34.visible = false;
          }

          // ---------- RECTANGLE PLANE UPDATE (m1, m2, m3, m4) ----------

          const quadOk =
            this._markerWithinTimeout('m1', now) &&
            this._markerWithinTimeout('m2', now) &&
            this._markerWithinTimeout('m3', now) &&
            this._markerWithinTimeout('m4', now);

          if (quadOk) {
            // center = average of four points
            this.center.set(0, 0, 0)
              .add(this.p1)
              .add(this.p2)
              .add(this.p3)
              .add(this.p4)
              .multiplyScalar(0.25);

            // Right vector: from m1 to m2
            this.right.subVectors(this.p2, this.p1);
            const width = this.right.length();
            if (width > 0.0001) this.right.normalize();

            // Up vector: from m1 to m4
            this.up.subVectors(this.p4, this.p1);
            const height = this.up.length();
            if (height > 0.0001) this.up.normalize();

            // Normal = right × up
            this.normal.crossVectors(this.right, this.up);
            if (this.normal.lengthSq() < 0.000001) {
              // Degenerate case, don't draw
              this.rectPlane.visible = false;
              return;
            }
            this.normal.normalize();

            // Build basis matrix (columns = right, up, normal)
            this.basisMatrix.makeBasis(this.right, this.up, this.normal);
            this.tempQuat.setFromRotationMatrix(this.basisMatrix);

            // Apply transform to plane
            this.rectPlane.position.copy(this.center);
            this.rectPlane.quaternion.copy(this.tempQuat);

            // Plane geometry in A-Frame is 1x1 by default, so scale to width/height
            this.rectPlane.scale.set(width, height, 1);

            this.rectPlane.visible = true;
          } else {
            this.rectPlane.visible = false;
          }
        }
      });
    </script>

    <a-scene
      embedded
      vr-mode-ui="enabled: false;"
      arjs="debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 4x4_BCH_13_5_5;"
    >
      <!-- simple lights -->
      <a-entity light="type: directional; intensity: 0.8;" position="0 1 0"></a-entity>
      <a-entity light="type: ambient; intensity: 0.4;"></a-entity>

      <!-- Markers: 1–4 only -->
      <a-marker type="barcode" value="1" id="m1" registerevents></a-marker>
      <a-marker type="barcode" value="2" id="m2" registerevents></a-marker>
      <a-marker type="barcode" value="3" id="m3" registerevents></a-marker>
      <a-marker type="barcode" value="4" id="m4" registerevents></a-marker>

      <!-- Followers: persistent spheres in world space -->
      <a-entity id="follower-m1">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m2">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m3">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <a-entity id="follower-m4">
        <a-sphere radius="0.10" color="red"></a-sphere>
      </a-entity>

      <!-- Cylinder groups: direct children of scene (world space) -->
      <a-entity id="cylinderGroup12"></a-entity>
      <a-entity id="cylinderGroup23"></a-entity>
      <a-entity id="cylinderGroup34"></a-entity>

      <!-- Rect plane: world-space plane we stretch between markers -->
      <a-plane
        id="rectPlane"
        color="#00ff00"
        opacity="0.4"
        side="double"
        visible="false"
        width="1"
        height="1"
      ></a-plane>

      <a-entity camera></a-entity>
      <a-entity run></a-entity>
    </a-scene>
  </body>
</html>
